{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nconst socket_io_adapter_1 = require(\"socket.io-adapter\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\n   * @private\n   */\n  _initAdapter() {\n    this.adapter = new ParentBroadcastAdapter(this, this.children);\n  }\n  emit(ev, ...args) {\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n  createChild(name) {\n    debug(\"creating child namespace %s\", name);\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n    if (this.server._opts.cleanupEmptyChildNamespaces) {\n      const remove = namespace._remove;\n      namespace._remove = socket => {\n        remove.call(namespace, socket);\n        if (namespace.sockets.size === 0) {\n          debug(\"closing child namespace %s\", name);\n          namespace.adapter.close();\n          this.server._nsps.delete(namespace.name);\n          this.children.delete(namespace);\n        }\n      };\n    }\n    this.server._nsps.set(name, namespace);\n    // @ts-ignore\n    this.server.sockets.emitReserved(\"new_namespace\", namespace);\n    return namespace;\n  }\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */\nclass ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n  constructor(parentNsp, children) {\n    super(parentNsp);\n    this.children = children;\n  }\n  broadcast(packet, opts) {\n    this.children.forEach(nsp => {\n      nsp.adapter.broadcast(packet, opts);\n    });\n  }\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","socket_io_adapter_1","debug_1","debug","default","Namespace","constructor","server","count","children","Set","_initAdapter","adapter","ParentBroadcastAdapter","emit","ev","args","forEach","nsp","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_opts","cleanupEmptyChildNamespaces","remove","_remove","socket","call","sockets","size","close","_nsps","delete","set","emitReserved","fetchSockets","Error","Adapter","parentNsp","broadcast","packet","opts"],"sources":["C:/Users/Admin/Desktop/SPORTSWEBAPP/frontend/node_modules/socket.io/dist/parent-namespace.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nconst socket_io_adapter_1 = require(\"socket.io-adapter\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this, this.children);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket) => {\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */\nclass ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    constructor(parentNsp, children) {\n        super(parentNsp);\n        this.children = children;\n    }\n    broadcast(packet, opts) {\n        this.children.forEach((nsp) => {\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,eAAe,GAAG,KAAK,CAAC;AAChC,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACxD,MAAME,OAAO,GAAGX,eAAe,CAACS,OAAO,CAAC,OAAO,CAAC,CAAC;AACjD,MAAMG,KAAK,GAAG,CAAC,CAAC,EAAED,OAAO,CAACE,OAAO,EAAE,4BAA4B,CAAC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMN,eAAe,SAASC,WAAW,CAACM,SAAS,CAAC;EAChDC,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,EAAE,IAAI,GAAGT,eAAe,CAACU,KAAK,EAAE,CAAC;IAC7C,IAAI,CAACC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC7B;EACA;AACJ;AACA;EACIC,YAAYA,CAAA,EAAG;IACX,IAAI,CAACC,OAAO,GAAG,IAAIC,sBAAsB,CAAC,IAAI,EAAE,IAAI,CAACJ,QAAQ,CAAC;EAClE;EACAK,IAAIA,CAACC,EAAE,EAAE,GAAGC,IAAI,EAAE;IACd,IAAI,CAACP,QAAQ,CAACQ,OAAO,CAAEC,GAAG,IAAK;MAC3BA,GAAG,CAACJ,IAAI,CAACC,EAAE,EAAE,GAAGC,IAAI,CAAC;IACzB,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACAG,WAAWA,CAACC,IAAI,EAAE;IACdjB,KAAK,CAAC,6BAA6B,EAAEiB,IAAI,CAAC;IAC1C,MAAMC,SAAS,GAAG,IAAItB,WAAW,CAACM,SAAS,CAAC,IAAI,CAACE,MAAM,EAAEa,IAAI,CAAC;IAC9DC,SAAS,CAACC,IAAI,GAAG,IAAI,CAACA,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;IACnC,IAAI,CAACC,SAAS,CAAC,SAAS,CAAC,CAACP,OAAO,CAAEQ,QAAQ,IAAKJ,SAAS,CAACK,EAAE,CAAC,SAAS,EAAED,QAAQ,CAAC,CAAC;IAClF,IAAI,CAACD,SAAS,CAAC,YAAY,CAAC,CAACP,OAAO,CAAEQ,QAAQ,IAAKJ,SAAS,CAACK,EAAE,CAAC,YAAY,EAAED,QAAQ,CAAC,CAAC;IACxF,IAAI,CAAChB,QAAQ,CAACkB,GAAG,CAACN,SAAS,CAAC;IAC5B,IAAI,IAAI,CAACd,MAAM,CAACqB,KAAK,CAACC,2BAA2B,EAAE;MAC/C,MAAMC,MAAM,GAAGT,SAAS,CAACU,OAAO;MAChCV,SAAS,CAACU,OAAO,GAAIC,MAAM,IAAK;QAC5BF,MAAM,CAACG,IAAI,CAACZ,SAAS,EAAEW,MAAM,CAAC;QAC9B,IAAIX,SAAS,CAACa,OAAO,CAACC,IAAI,KAAK,CAAC,EAAE;UAC9BhC,KAAK,CAAC,4BAA4B,EAAEiB,IAAI,CAAC;UACzCC,SAAS,CAACT,OAAO,CAACwB,KAAK,CAAC,CAAC;UACzB,IAAI,CAAC7B,MAAM,CAAC8B,KAAK,CAACC,MAAM,CAACjB,SAAS,CAACD,IAAI,CAAC;UACxC,IAAI,CAACX,QAAQ,CAAC6B,MAAM,CAACjB,SAAS,CAAC;QACnC;MACJ,CAAC;IACL;IACA,IAAI,CAACd,MAAM,CAAC8B,KAAK,CAACE,GAAG,CAACnB,IAAI,EAAEC,SAAS,CAAC;IACtC;IACA,IAAI,CAACd,MAAM,CAAC2B,OAAO,CAACM,YAAY,CAAC,eAAe,EAAEnB,SAAS,CAAC;IAC5D,OAAOA,SAAS;EACpB;EACAoB,YAAYA,CAAA,EAAG;IACX;IACA;IACA;IACA;IACA;IACA,MAAM,IAAIC,KAAK,CAAC,sDAAsD,CAAC;EAC3E;AACJ;AACA9C,OAAO,CAACE,eAAe,GAAGA,eAAe;AACzCA,eAAe,CAACU,KAAK,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA,MAAMK,sBAAsB,SAASZ,mBAAmB,CAAC0C,OAAO,CAAC;EAC7DrC,WAAWA,CAACsC,SAAS,EAAEnC,QAAQ,EAAE;IAC7B,KAAK,CAACmC,SAAS,CAAC;IAChB,IAAI,CAACnC,QAAQ,GAAGA,QAAQ;EAC5B;EACAoC,SAASA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACpB,IAAI,CAACtC,QAAQ,CAACQ,OAAO,CAAEC,GAAG,IAAK;MAC3BA,GAAG,CAACN,OAAO,CAACiC,SAAS,CAACC,MAAM,EAAEC,IAAI,CAAC;IACvC,CAAC,CAAC;EACN;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}