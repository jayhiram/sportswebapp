{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = require(\"./in-memory-adapter\");\nconst debug_1 = require(\"debug\");\nconst crypto_1 = require(\"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n  return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function (MessageType) {\n  MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n  MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n  MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n  MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n  MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n  MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n  MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n  MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n  MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n  MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n  MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n  MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n  MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n  return {\n    rooms: [...opts.rooms],\n    except: [...opts.except],\n    flags: opts.flags\n  };\n}\nfunction decodeOptions(opts) {\n  return {\n    rooms: new Set(opts.rooms),\n    except: new Set(opts.except),\n    flags: opts.flags\n  };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */\nclass ClusterAdapter extends in_memory_adapter_1.Adapter {\n  constructor(nsp) {\n    super(nsp);\n    this.requests = new Map();\n    this.ackRequests = new Map();\n    this.uid = randomId();\n  }\n  /**\n   * Called when receiving a message from another member of the cluster.\n   *\n   * @param message\n   * @param offset\n   * @protected\n   */\n  onMessage(message, offset) {\n    if (message.uid === this.uid) {\n      return debug(\"[%s] ignore message from self\", this.uid);\n    }\n    debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n    switch (message.type) {\n      case MessageType.BROADCAST:\n        {\n          const withAck = message.data.requestId !== undefined;\n          if (withAck) {\n            super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), clientCount => {\n              debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n              this.publishResponse(message.uid, {\n                type: MessageType.BROADCAST_CLIENT_COUNT,\n                data: {\n                  requestId: message.data.requestId,\n                  clientCount\n                }\n              });\n            }, arg => {\n              debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n              this.publishResponse(message.uid, {\n                type: MessageType.BROADCAST_ACK,\n                data: {\n                  requestId: message.data.requestId,\n                  packet: arg\n                }\n              });\n            });\n          } else {\n            const packet = message.data.packet;\n            const opts = decodeOptions(message.data.opts);\n            this.addOffsetIfNecessary(packet, opts, offset);\n            super.broadcast(packet, opts);\n          }\n          break;\n        }\n      case MessageType.SOCKETS_JOIN:\n        super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n        break;\n      case MessageType.SOCKETS_LEAVE:\n        super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n        break;\n      case MessageType.DISCONNECT_SOCKETS:\n        super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n        break;\n      case MessageType.FETCH_SOCKETS:\n        {\n          debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n          super.fetchSockets(decodeOptions(message.data.opts)).then(localSockets => {\n            this.publishResponse(message.uid, {\n              type: MessageType.FETCH_SOCKETS_RESPONSE,\n              data: {\n                requestId: message.data.requestId,\n                sockets: localSockets.map(socket => {\n                  // remove sessionStore from handshake, as it may contain circular references\n                  const _a = socket.handshake,\n                    {\n                      sessionStore\n                    } = _a,\n                    handshake = __rest(_a, [\"sessionStore\"]);\n                  return {\n                    id: socket.id,\n                    handshake,\n                    rooms: [...socket.rooms],\n                    data: socket.data\n                  };\n                })\n              }\n            });\n          });\n          break;\n        }\n      case MessageType.SERVER_SIDE_EMIT:\n        {\n          const packet = message.data.packet;\n          const withAck = message.data.requestId !== undefined;\n          if (!withAck) {\n            this.nsp._onServerSideEmit(packet);\n            return;\n          }\n          let called = false;\n          const callback = arg => {\n            // only one argument is expected\n            if (called) {\n              return;\n            }\n            called = true;\n            debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n            this.publishResponse(message.uid, {\n              type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n              data: {\n                requestId: message.data.requestId,\n                packet: arg\n              }\n            });\n          };\n          this.nsp._onServerSideEmit([...packet, callback]);\n          break;\n        }\n      // @ts-ignore\n      case MessageType.BROADCAST_CLIENT_COUNT:\n      // @ts-ignore\n      case MessageType.BROADCAST_ACK:\n      // @ts-ignore\n      case MessageType.FETCH_SOCKETS_RESPONSE:\n      // @ts-ignore\n      case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n        // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n        // always call the onMessage() method\n        this.onResponse(message);\n        break;\n      default:\n        debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n    }\n  }\n  /**\n   * Called when receiving a response from another member of the cluster.\n   *\n   * @param response\n   * @protected\n   */\n  onResponse(response) {\n    var _a, _b;\n    const requestId = response.data.requestId;\n    debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n    switch (response.type) {\n      case MessageType.BROADCAST_CLIENT_COUNT:\n        {\n          (_a = this.ackRequests.get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n          break;\n        }\n      case MessageType.BROADCAST_ACK:\n        {\n          (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n          break;\n        }\n      case MessageType.FETCH_SOCKETS_RESPONSE:\n        {\n          const request = this.requests.get(requestId);\n          if (!request) {\n            return;\n          }\n          request.current++;\n          response.data.sockets.forEach(socket => request.responses.push(socket));\n          if (request.current === request.expected) {\n            clearTimeout(request.timeout);\n            request.resolve(request.responses);\n            this.requests.delete(requestId);\n          }\n          break;\n        }\n      case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n        {\n          const request = this.requests.get(requestId);\n          if (!request) {\n            return;\n          }\n          request.current++;\n          request.responses.push(response.data.packet);\n          if (request.current === request.expected) {\n            clearTimeout(request.timeout);\n            request.resolve(null, request.responses);\n            this.requests.delete(requestId);\n          }\n          break;\n        }\n      default:\n        // @ts-ignore\n        debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n    }\n  }\n  async broadcast(packet, opts) {\n    var _a;\n    const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n    if (!onlyLocal) {\n      try {\n        const offset = await this.publishAndReturnOffset({\n          type: MessageType.BROADCAST,\n          data: {\n            packet,\n            opts: encodeOptions(opts)\n          }\n        });\n        this.addOffsetIfNecessary(packet, opts, offset);\n      } catch (e) {\n        return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n      }\n    }\n    super.broadcast(packet, opts);\n  }\n  /**\n   * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n   * reconnects after a temporary disconnection.\n   *\n   * @param packet\n   * @param opts\n   * @param offset\n   * @private\n   */\n  addOffsetIfNecessary(packet, opts, offset) {\n    var _a;\n    if (!this.nsp.server.opts.connectionStateRecovery) {\n      return;\n    }\n    const isEventPacket = packet.type === 2;\n    // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n    // restored on another server upon reconnection\n    const withoutAcknowledgement = packet.id === undefined;\n    const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n    if (isEventPacket && withoutAcknowledgement && notVolatile) {\n      packet.data.push(offset);\n    }\n  }\n  broadcastWithAck(packet, opts, clientCountCallback, ack) {\n    var _a;\n    const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n    if (!onlyLocal) {\n      const requestId = randomId();\n      this.ackRequests.set(requestId, {\n        clientCountCallback,\n        ack\n      });\n      this.publish({\n        type: MessageType.BROADCAST,\n        data: {\n          packet,\n          requestId,\n          opts: encodeOptions(opts)\n        }\n      });\n      // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n      // will simply clean up the ackRequests map after the given delay\n      setTimeout(() => {\n        this.ackRequests.delete(requestId);\n      }, opts.flags.timeout);\n    }\n    super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n  }\n  async addSockets(opts, rooms) {\n    var _a;\n    const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n    if (!onlyLocal) {\n      try {\n        await this.publishAndReturnOffset({\n          type: MessageType.SOCKETS_JOIN,\n          data: {\n            opts: encodeOptions(opts),\n            rooms\n          }\n        });\n      } catch (e) {\n        debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n      }\n    }\n    super.addSockets(opts, rooms);\n  }\n  async delSockets(opts, rooms) {\n    var _a;\n    const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n    if (!onlyLocal) {\n      try {\n        await this.publishAndReturnOffset({\n          type: MessageType.SOCKETS_LEAVE,\n          data: {\n            opts: encodeOptions(opts),\n            rooms\n          }\n        });\n      } catch (e) {\n        debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n      }\n    }\n    super.delSockets(opts, rooms);\n  }\n  async disconnectSockets(opts, close) {\n    var _a;\n    const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n    if (!onlyLocal) {\n      try {\n        await this.publishAndReturnOffset({\n          type: MessageType.DISCONNECT_SOCKETS,\n          data: {\n            opts: encodeOptions(opts),\n            close\n          }\n        });\n      } catch (e) {\n        debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n      }\n    }\n    super.disconnectSockets(opts, close);\n  }\n  async fetchSockets(opts) {\n    var _a;\n    const [localSockets, serverCount] = await Promise.all([super.fetchSockets(opts), this.serverCount()]);\n    const expectedResponseCount = serverCount - 1;\n    if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n      return localSockets;\n    }\n    const requestId = randomId();\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const storedRequest = this.requests.get(requestId);\n        if (storedRequest) {\n          reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n          this.requests.delete(requestId);\n        }\n      }, opts.flags.timeout || DEFAULT_TIMEOUT);\n      const storedRequest = {\n        type: MessageType.FETCH_SOCKETS,\n        resolve,\n        timeout,\n        current: 0,\n        expected: expectedResponseCount,\n        responses: localSockets\n      };\n      this.requests.set(requestId, storedRequest);\n      this.publish({\n        type: MessageType.FETCH_SOCKETS,\n        data: {\n          opts: encodeOptions(opts),\n          requestId\n        }\n      });\n    });\n  }\n  async serverSideEmit(packet) {\n    const withAck = typeof packet[packet.length - 1] === \"function\";\n    if (!withAck) {\n      return this.publish({\n        type: MessageType.SERVER_SIDE_EMIT,\n        data: {\n          packet\n        }\n      });\n    }\n    const ack = packet.pop();\n    const expectedResponseCount = (await this.serverCount()) - 1;\n    debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n    if (expectedResponseCount <= 0) {\n      return ack(null, []);\n    }\n    const requestId = randomId();\n    const timeout = setTimeout(() => {\n      const storedRequest = this.requests.get(requestId);\n      if (storedRequest) {\n        ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n        this.requests.delete(requestId);\n      }\n    }, DEFAULT_TIMEOUT);\n    const storedRequest = {\n      type: MessageType.SERVER_SIDE_EMIT,\n      resolve: ack,\n      timeout,\n      current: 0,\n      expected: expectedResponseCount,\n      responses: []\n    };\n    this.requests.set(requestId, storedRequest);\n    this.publish({\n      type: MessageType.SERVER_SIDE_EMIT,\n      data: {\n        requestId,\n        packet\n      }\n    });\n  }\n  publish(message) {\n    this.publishAndReturnOffset(message).catch(err => {\n      debug(\"[%s] error while publishing message: %s\", this.uid, err);\n    });\n  }\n  publishAndReturnOffset(message) {\n    message.uid = this.uid;\n    message.nsp = this.nsp.name;\n    return this.doPublish(message);\n  }\n  publishResponse(requesterUid, response) {\n    response.uid = this.uid;\n    response.nsp = this.nsp.name;\n    this.doPublishResponse(requesterUid, response).catch(err => {\n      debug(\"[%s] error while publishing response: %s\", this.uid, err);\n    });\n  }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n  constructor(nsp, opts) {\n    super(nsp);\n    this.nodesMap = new Map(); // uid => timestamp of last message\n    this.customRequests = new Map();\n    this._opts = Object.assign({\n      heartbeatInterval: 5000,\n      heartbeatTimeout: 10000\n    }, opts);\n    this.cleanupTimer = setInterval(() => {\n      const now = Date.now();\n      this.nodesMap.forEach((lastSeen, uid) => {\n        const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n        if (nodeSeemsDown) {\n          debug(\"[%s] node %s seems down\", this.uid, uid);\n          this.removeNode(uid);\n        }\n      });\n    }, 1000);\n  }\n  init() {\n    this.publish({\n      type: MessageType.INITIAL_HEARTBEAT\n    });\n  }\n  scheduleHeartbeat() {\n    if (this.heartbeatTimer) {\n      this.heartbeatTimer.refresh();\n    } else {\n      this.heartbeatTimer = setTimeout(() => {\n        this.publish({\n          type: MessageType.HEARTBEAT\n        });\n      }, this._opts.heartbeatInterval);\n    }\n  }\n  close() {\n    this.publish({\n      type: MessageType.ADAPTER_CLOSE\n    });\n    clearTimeout(this.heartbeatTimer);\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n  }\n  onMessage(message, offset) {\n    if (message.uid === this.uid) {\n      return debug(\"[%s] ignore message from self\", this.uid);\n    }\n    if (message.uid && message.uid !== EMITTER_UID) {\n      // we track the UID of each sender, in order to know how many servers there are in the cluster\n      this.nodesMap.set(message.uid, Date.now());\n    }\n    debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n    switch (message.type) {\n      case MessageType.INITIAL_HEARTBEAT:\n        this.publish({\n          type: MessageType.HEARTBEAT\n        });\n        break;\n      case MessageType.HEARTBEAT:\n        // nothing to do\n        break;\n      case MessageType.ADAPTER_CLOSE:\n        this.removeNode(message.uid);\n        break;\n      default:\n        super.onMessage(message, offset);\n    }\n  }\n  serverCount() {\n    return Promise.resolve(1 + this.nodesMap.size);\n  }\n  publish(message) {\n    this.scheduleHeartbeat();\n    return super.publish(message);\n  }\n  async serverSideEmit(packet) {\n    const withAck = typeof packet[packet.length - 1] === \"function\";\n    if (!withAck) {\n      return this.publish({\n        type: MessageType.SERVER_SIDE_EMIT,\n        data: {\n          packet\n        }\n      });\n    }\n    const ack = packet.pop();\n    const expectedResponseCount = this.nodesMap.size;\n    debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n    if (expectedResponseCount <= 0) {\n      return ack(null, []);\n    }\n    const requestId = randomId();\n    const timeout = setTimeout(() => {\n      const storedRequest = this.customRequests.get(requestId);\n      if (storedRequest) {\n        ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n        this.customRequests.delete(requestId);\n      }\n    }, DEFAULT_TIMEOUT);\n    const storedRequest = {\n      type: MessageType.SERVER_SIDE_EMIT,\n      resolve: ack,\n      timeout,\n      missingUids: new Set([...this.nodesMap.keys()]),\n      responses: []\n    };\n    this.customRequests.set(requestId, storedRequest);\n    this.publish({\n      type: MessageType.SERVER_SIDE_EMIT,\n      data: {\n        requestId,\n        packet\n      }\n    });\n  }\n  async fetchSockets(opts) {\n    var _a;\n    const [localSockets, serverCount] = await Promise.all([super.fetchSockets({\n      rooms: opts.rooms,\n      except: opts.except,\n      flags: {\n        local: true\n      }\n    }), this.serverCount()]);\n    const expectedResponseCount = serverCount - 1;\n    if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n      return localSockets;\n    }\n    const requestId = randomId();\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const storedRequest = this.customRequests.get(requestId);\n        if (storedRequest) {\n          reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n          this.customRequests.delete(requestId);\n        }\n      }, opts.flags.timeout || DEFAULT_TIMEOUT);\n      const storedRequest = {\n        type: MessageType.FETCH_SOCKETS,\n        resolve,\n        timeout,\n        missingUids: new Set([...this.nodesMap.keys()]),\n        responses: localSockets\n      };\n      this.customRequests.set(requestId, storedRequest);\n      this.publish({\n        type: MessageType.FETCH_SOCKETS,\n        data: {\n          opts: encodeOptions(opts),\n          requestId\n        }\n      });\n    });\n  }\n  onResponse(response) {\n    const requestId = response.data.requestId;\n    debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n    switch (response.type) {\n      case MessageType.FETCH_SOCKETS_RESPONSE:\n        {\n          const request = this.customRequests.get(requestId);\n          if (!request) {\n            return;\n          }\n          response.data.sockets.forEach(socket => request.responses.push(socket));\n          request.missingUids.delete(response.uid);\n          if (request.missingUids.size === 0) {\n            clearTimeout(request.timeout);\n            request.resolve(request.responses);\n            this.customRequests.delete(requestId);\n          }\n          break;\n        }\n      case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n        {\n          const request = this.customRequests.get(requestId);\n          if (!request) {\n            return;\n          }\n          request.responses.push(response.data.packet);\n          request.missingUids.delete(response.uid);\n          if (request.missingUids.size === 0) {\n            clearTimeout(request.timeout);\n            request.resolve(null, request.responses);\n            this.customRequests.delete(requestId);\n          }\n          break;\n        }\n      default:\n        super.onResponse(response);\n    }\n  }\n  removeNode(uid) {\n    this.customRequests.forEach((request, requestId) => {\n      request.missingUids.delete(uid);\n      if (request.missingUids.size === 0) {\n        clearTimeout(request.timeout);\n        if (request.type === MessageType.FETCH_SOCKETS) {\n          request.resolve(request.responses);\n        } else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n          request.resolve(null, request.responses);\n        }\n        this.customRequests.delete(requestId);\n      }\n    });\n    this.nodesMap.delete(uid);\n  }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","defineProperty","exports","value","ClusterAdapterWithHeartbeat","ClusterAdapter","MessageType","in_memory_adapter_1","require","debug_1","crypto_1","debug","EMITTER_UID","DEFAULT_TIMEOUT","randomId","randomBytes","toString","encodeOptions","opts","rooms","except","flags","decodeOptions","Set","Adapter","constructor","nsp","requests","Map","ackRequests","uid","onMessage","message","offset","type","BROADCAST","withAck","data","requestId","undefined","broadcastWithAck","packet","clientCount","publishResponse","BROADCAST_CLIENT_COUNT","arg","BROADCAST_ACK","addOffsetIfNecessary","broadcast","SOCKETS_JOIN","addSockets","SOCKETS_LEAVE","delSockets","DISCONNECT_SOCKETS","disconnectSockets","close","FETCH_SOCKETS","fetchSockets","then","localSockets","FETCH_SOCKETS_RESPONSE","sockets","map","socket","_a","handshake","sessionStore","id","SERVER_SIDE_EMIT","_onServerSideEmit","called","callback","SERVER_SIDE_EMIT_RESPONSE","onResponse","response","_b","get","clientCountCallback","ack","request","current","forEach","responses","push","expected","clearTimeout","timeout","resolve","delete","onlyLocal","local","publishAndReturnOffset","server","connectionStateRecovery","isEventPacket","withoutAcknowledgement","notVolatile","volatile","set","publish","setTimeout","serverCount","Promise","all","expectedResponseCount","reject","storedRequest","Error","serverSideEmit","pop","catch","err","name","doPublish","requesterUid","doPublishResponse","nodesMap","customRequests","_opts","assign","heartbeatInterval","heartbeatTimeout","cleanupTimer","setInterval","now","Date","lastSeen","nodeSeemsDown","removeNode","init","INITIAL_HEARTBEAT","scheduleHeartbeat","heartbeatTimer","refresh","HEARTBEAT","ADAPTER_CLOSE","clearInterval","size","missingUids","keys"],"sources":["C:/Users/Admin/Desktop/SPORTSWEBAPP/frontend/node_modules/socket.io-adapter/dist/cluster-adapter.js"],"sourcesContent":["\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = require(\"./in-memory-adapter\");\nconst debug_1 = require(\"debug\");\nconst crypto_1 = require(\"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [...opts.rooms],\n        except: [...opts.except],\n        flags: opts.flags,\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags,\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */\nclass ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.BROADCAST: {\n                const withAck = message.data.requestId !== undefined;\n                if (withAck) {\n                    super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {\n                        debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_CLIENT_COUNT,\n                            data: {\n                                requestId: message.data.requestId,\n                                clientCount,\n                            },\n                        });\n                    }, (arg) => {\n                        debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_ACK,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg,\n                            },\n                        });\n                    });\n                }\n                else {\n                    const packet = message.data.packet;\n                    const opts = decodeOptions(message.data.opts);\n                    this.addOffsetIfNecessary(packet, opts, offset);\n                    super.broadcast(packet, opts);\n                }\n                break;\n            }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS: {\n                debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                super\n                    .fetchSockets(decodeOptions(message.data.opts))\n                    .then((localSockets) => {\n                    this.publishResponse(message.uid, {\n                        type: MessageType.FETCH_SOCKETS_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            sockets: localSockets.map((socket) => {\n                                // remove sessionStore from handshake, as it may contain circular references\n                                const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\"sessionStore\"]);\n                                return {\n                                    id: socket.id,\n                                    handshake,\n                                    rooms: [...socket.rooms],\n                                    data: socket.data,\n                                };\n                            }),\n                        },\n                    });\n                });\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT: {\n                const packet = message.data.packet;\n                const withAck = message.data.requestId !== undefined;\n                if (!withAck) {\n                    this.nsp._onServerSideEmit(packet);\n                    return;\n                }\n                let called = false;\n                const callback = (arg) => {\n                    // only one argument is expected\n                    if (called) {\n                        return;\n                    }\n                    called = true;\n                    debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                    this.publishResponse(message.uid, {\n                        type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            packet: arg,\n                        },\n                    });\n                };\n                this.nsp._onServerSideEmit([...packet, callback]);\n                break;\n            }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */\n    onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.BROADCAST_CLIENT_COUNT: {\n                (_a = this.ackRequests\n                    .get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                break;\n            }\n            case MessageType.BROADCAST_ACK: {\n                (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                break;\n            }\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                request.responses.push(response.data.packet);\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts),\n                    },\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            }\n            catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */\n    addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack,\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts),\n                },\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(() => {\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets,\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = (await this.serverCount()) - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: [],\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err) => {\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err) => {\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts) {\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000,\n        }, opts);\n        this.cleanupTimer = setInterval(() => {\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid) => {\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT,\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        }\n        else {\n            this.heartbeatTimer = setTimeout(() => {\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE,\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                // nothing to do\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([...this.nodesMap.keys()]),\n            responses: [],\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true,\n                },\n            }),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([...this.nodesMap.keys()]),\n                responses: localSockets,\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.responses.push(response.data.packet);\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId) => {\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                }\n                else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}